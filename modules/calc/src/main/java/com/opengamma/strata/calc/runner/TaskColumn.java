/**
 * Copyright (C) 2016 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.strata.calc.runner;

import java.util.Set;

import org.joda.beans.BeanDefinition;
import org.joda.beans.ImmutableBean;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaBean;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.light.LightMetaBean;

import com.opengamma.strata.basics.CalculationTarget;
import com.opengamma.strata.calc.Column;
import com.opengamma.strata.calc.config.MarketDataRules;
import com.opengamma.strata.calc.config.Measure;
import com.opengamma.strata.calc.config.ReportingCurrency;
import com.opengamma.strata.calc.marketdata.mapping.MarketDataMappings;
import com.opengamma.strata.collect.ArgChecker;
import com.opengamma.strata.collect.Messages;

/**
 * A single column used to build the calculation tasks.
 * <p>
 * Each {@link CalculationTask} calculates a grid of results.
 * This class capture details of each column.
 */
@BeanDefinition(style = "light")
public final class TaskColumn implements ImmutableBean {

  /**
   * The column index of the cell in the results grid.
   */
  @PropertyDefinition(validate = "ArgChecker.notNegative")
  private final int columnIndex;
  /**
   * The measure to be calculated.
   * <p>
   * This defines the calculation being performed, such as 'PresentValue' or 'ParRate'.
   */
  @PropertyDefinition(validate = "notNull")
  private final Measure measure;
  /**
   * The calculation parameters, used to control the how the calculation is performed.
   * <p>
   * The parameters specified here must be specific to the target and measure.
   * The reporting currency parameter will not be present.
   */
  @PropertyDefinition(validate = "notNull")
  private final CalculationParameters parameters;
  /**
   * The mappings to select market data.
   */
  @PropertyDefinition(validate = "notNull")
  private final MarketDataMappings marketDataMappings;
  /**
   * The reporting currency.
   */
  @PropertyDefinition(validate = "notNull")
  private final ReportingCurrency reportingCurrency;

  //-------------------------------------------------------------------------
  // creates the task column for the target
  static TaskColumn of(CalculationTarget target, Column column, int colIndex) {
    Measure measure = column.getMeasure();
    CalculationParameters parameters = column.getParameters();

    // extract the known parameters
    MarketDataRules mdRules = column.getMarketDataRules();
    MarketDataMappings mappings = mdRules.mappings(target).orElse(NoMatchingRuleMappings.INSTANCE);
    ReportingCurrency reportingCurrency = parameters.findParameter(ReportingCurrency.class)
        .orElse(ReportingCurrency.NATURAL);

    // filter the parameters to remove extracted items
    CalculationParameters filteredParams = parameters
        .filter(target, measure)
        .without(ReportingCurrency.class);

    // build
    return new TaskColumn(colIndex, measure, filteredParams, mappings, reportingCurrency);
  }

  //-------------------------------------------------------------------------
  @Override
  public String toString() {
    return Messages.format(
        "TaskColumn[index={}, measure={}, currency={}]", columnIndex, measure, reportingCurrency);
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code TaskColumn}.
   */
  private static MetaBean META_BEAN = LightMetaBean.of(TaskColumn.class);

  /**
   * The meta-bean for {@code TaskColumn}.
   * @return the meta-bean, not null
   */
  public static MetaBean meta() {
    return META_BEAN;
  }

  static {
    JodaBeanUtils.registerMetaBean(META_BEAN);
  }

  private TaskColumn(
      int columnIndex,
      Measure measure,
      CalculationParameters parameters,
      MarketDataMappings marketDataMappings,
      ReportingCurrency reportingCurrency) {
    ArgChecker.notNegative(columnIndex, "columnIndex");
    JodaBeanUtils.notNull(measure, "measure");
    JodaBeanUtils.notNull(parameters, "parameters");
    JodaBeanUtils.notNull(marketDataMappings, "marketDataMappings");
    JodaBeanUtils.notNull(reportingCurrency, "reportingCurrency");
    this.columnIndex = columnIndex;
    this.measure = measure;
    this.parameters = parameters;
    this.marketDataMappings = marketDataMappings;
    this.reportingCurrency = reportingCurrency;
  }

  @Override
  public MetaBean metaBean() {
    return META_BEAN;
  }

  @Override
  public <R> Property<R> property(String propertyName) {
    return metaBean().<R>metaProperty(propertyName).createProperty(this);
  }

  @Override
  public Set<String> propertyNames() {
    return metaBean().metaPropertyMap().keySet();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the column index of the cell in the results grid.
   * @return the value of the property
   */
  public int getColumnIndex() {
    return columnIndex;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the measure to be calculated.
   * <p>
   * This defines the calculation being performed, such as 'PresentValue' or 'ParRate'.
   * @return the value of the property, not null
   */
  public Measure getMeasure() {
    return measure;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the calculation parameters, used to control the how the calculation is performed.
   * <p>
   * The parameters specified here must be specific to the target and measure.
   * The reporting currency parameter will not be present.
   * @return the value of the property, not null
   */
  public CalculationParameters getParameters() {
    return parameters;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the mappings to select market data.
   * @return the value of the property, not null
   */
  public MarketDataMappings getMarketDataMappings() {
    return marketDataMappings;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the reporting currency.
   * @return the value of the property, not null
   */
  public ReportingCurrency getReportingCurrency() {
    return reportingCurrency;
  }

  //-----------------------------------------------------------------------
  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      TaskColumn other = (TaskColumn) obj;
      return (columnIndex == other.columnIndex) &&
          JodaBeanUtils.equal(measure, other.measure) &&
          JodaBeanUtils.equal(parameters, other.parameters) &&
          JodaBeanUtils.equal(marketDataMappings, other.marketDataMappings) &&
          JodaBeanUtils.equal(reportingCurrency, other.reportingCurrency);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = getClass().hashCode();
    hash = hash * 31 + JodaBeanUtils.hashCode(columnIndex);
    hash = hash * 31 + JodaBeanUtils.hashCode(measure);
    hash = hash * 31 + JodaBeanUtils.hashCode(parameters);
    hash = hash * 31 + JodaBeanUtils.hashCode(marketDataMappings);
    hash = hash * 31 + JodaBeanUtils.hashCode(reportingCurrency);
    return hash;
  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}
