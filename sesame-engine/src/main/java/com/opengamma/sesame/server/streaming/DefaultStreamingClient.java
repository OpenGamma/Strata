/**
 * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.sesame.server.streaming;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicReference;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Function;
import com.opengamma.OpenGammaRuntimeException;
import com.opengamma.id.UniqueId;
import com.opengamma.sesame.engine.Results;
import com.opengamma.util.ArgumentChecker;

/**
 * Streaming client implementation.
 */
public class DefaultStreamingClient implements PublisherAwareStreamingClient {

  /**
   * Logger for the class.
   */
  private static final Logger s_logger = LoggerFactory.getLogger(DefaultStreamingClient.class);

  /**
   * Enum indicating the possible states for the client.
   */
  private enum RunState {
    /**
     * Indicates the client has paused, so messages will be queued up
     * until a listener is ready to receive them.
     */
    PAUSED,
    /**
     * Indicates the client is running and publishing messages
     * to a listener.
     */
    RUNNING,
    /**
     * Indicates the client is stopped and no longer publishing
     * messages to a listener.
     */
    STOPPED
  }

  /**
   * The unique identifier for the client.
   */
  private final UniqueId _uniqueId;

  /**
   * Indicates the current run state for the client. The client will be
   * initialised in the paused start. This will change to running when a
   * listener is registered. When the process is no longer required, or
   * an error occurs then the state will change to stopped.
   */
  private final AtomicReference<RunState> _runState = new AtomicReference<>(RunState.PAUSED);

  /**
   * The queue of messages received that haven't been sent to a listener. In
   * general this queue will build until a listener connects, then all the
   * pending messages will be sent out. As we may receive a mix of results
   * and status message we need to encode them all in a consistent way, the use
   * of the Function<> type allows this.</>
   */
  private final ConcurrentLinkedQueue<Function<StreamingClientResultListener, Object>> _pendingMessages =
      new ConcurrentLinkedQueue<>();

  /**
   * The listener for results generated by the client. Until the listener is
   * registered, messages will be queued up.
   */
  private StreamingClientResultListener _resultListener;

  /**
   * Creates the client with the specified unique identifier.
   *
   * @param uniqueId the unique identifier for the client, not null
   */
  public DefaultStreamingClient(UniqueId uniqueId) {
    _uniqueId = ArgumentChecker.notNull(uniqueId, "uniqueId");
  }

  @Override
  public UniqueId getUniqueId() {
    return _uniqueId;
  }

  /**
   * Register the supplied listener to receive streaming results.
   *
   * @param listener the listener to send results to
   */
  @Override
  public void registerListener(StreamingClientResultListener listener) {

    if (_resultListener != null) {
      throw new OpenGammaRuntimeException("Listener already assigned - unable to reassign");
    }

    _resultListener = ArgumentChecker.notNull(listener, "listener");
    drainPendingMessages();

    // It is possible that the client has actually been stopped by the point
    // that a listener attaches. So we only change the state to running if we
    // were in the paused state.
    _runState.compareAndSet(RunState.PAUSED, RunState.RUNNING);
  }

  @Override
  public void resultsReceived(Results results) {

    switch (_runState.get()) {

      case PAUSED:
        _pendingMessages.offer(new ResultsReceivedMessage(results));
        break;
      case RUNNING:
        // Need to drain in case anything got added in between registerListener's
        // call to drainPendingMessages and assignment to the field
        drainPendingMessages();
        _resultListener.resultsReceived(results);
        break;
      default:
        s_logger.warn("Received cycle results but client has been stopped");
    }
  }

  @Override
  public void processCompleted() {

    switch (_runState.get()) {

      case PAUSED:
        _pendingMessages.offer(ProcessCompletedMessage.INSTANCE);
        break;
      case RUNNING:
        // Need to drain in case anything got added in between registerListener's
        // call to drainPendingMessages and state changing
        drainPendingMessages();
        _resultListener.processCompleted();
        break;
      default:
        s_logger.warn("Received process complete message but client has been stopped");
    }
  }

  @Override
  public void serverConnectionFailed(Exception e) {
    throw new UnsupportedOperationException("This method is only intended for use by the remote client");
  }

  @Override
  public boolean isRunning() {
    return !isStopped();
  }

  @Override
  public boolean isStopped() {
    return _runState.get() == RunState.STOPPED;
  }

  @Override
  public void stop() {
    _runState.set(RunState.STOPPED);
  }

  private void drainPendingMessages() {

    Function<StreamingClientResultListener, Object> message;
    while ((message = _pendingMessages.poll()) != null) {
      message.apply(_resultListener);
    }
  }
}
